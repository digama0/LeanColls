{"name":"Std.Tactic.Congr","instances":[],"imports":["Init","Lean.Meta.Tactic.Congr","Lean.Elab.Tactic.Config","Std.Tactic.RCases","Std.Tactic.Ext"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L78-L109","name":"Std.Tactic.rcongr","line":78,"kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.rcongr","doc":"Repeatedly apply `congr` and `ext`, using the given patterns as arguments for `ext`.\n\nThere are two ways this tactic stops:\n* `congr` fails (makes no progress), after having already applied `ext`.\n* `congr` canceled out the last usage of `ext`. In this case, the state is reverted to before\n  the `congr` was applied.\n\nFor example, when the goal is\n```\n⊢ (fun x => f x + 3) '' s = (fun x => g x + 3) '' s\n```\nthen `rcongr x` produces the goal\n```\nx : α ⊢ f x = g x\n```\nThis gives the same result as `congr; ext x; congr`.\n\nIn contrast, `congr` would produce\n```\n⊢ (fun x => f x + 3) = (fun x => g x + 3)\n```\nand `congr with x` (or `congr; ext x`) would produce\n```\nx : α ⊢ f x + 3 = g x + 3\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.rcongr\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcongr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L64-L76","name":"Std.Tactic.rcongrCore","line":64,"kind":"opaque","docLink":"./Std/Tactic/Congr.html#Std.Tactic.rcongrCore","doc":"Recursive core of `rcongr`. Calls `ext pats <;> congr` and then itself recursively,\nunless `ext pats <;> congr` made no progress.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.rcongrCore\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcongrCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(config : <a href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config\">Std.Tactic.Congr.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acc : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L31-L44","name":"Std.Tactic.congrConfigWith","line":31,"kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.congrConfigWith","doc":"Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\n* `congr n` controls the depth of the recursive applications.\n  This is useful when `congr` is too aggressive in breaking down the goal.\n  For example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n  `congr` produces the goals `⊢ x = y` and `⊢ y = x`,\n  while `congr 2` produces the intended `⊢ x + y = y + x`.\n* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.\n* You can use `congr with p (: n)?` to call `ext p (: n)?` to all subgoals generated by `congr`.\n  For example, if the goal is `⊢ f '' s = g '' s` then `congr with x` generates the goal\n  `x : α ⊢ f x = g x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.congrConfigWith\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">congrConfigWith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L28-L29","name":"Std.Tactic.congrConfig","line":28,"kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.congrConfig","doc":"Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.congrConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">congrConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L25-L26","name":"Std.Tactic.Congr.elabConfig","line":25,"kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.Congr.elabConfig","doc":"Function elaborating `Congr.Config` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.elabConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Congr</span>.<span class=\"name\">elabConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config\">Std.Tactic.Congr.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L23-L23","name":"Std.Tactic.Congr.Config.closePost","line":23,"kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config.closePost","doc":"If `closePost := true`, it will try again on goals on which `congr` failed to make progress\nwith default transparency. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config.closePost\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Congr</span>.<span class=\"name\">Config</span>.<span class=\"name\">closePost</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config\">Std.Tactic.Congr.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L20-L20","name":"Std.Tactic.Congr.Config.closePre","line":20,"kind":"def","docLink":"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config.closePre","doc":"If `closePre := true`, it will attempt to close new goals using `Eq.refl`, `HEq.refl`, and\n`assumption` with reducible transparency. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config.closePre\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Congr</span>.<span class=\"name\">Config</span>.<span class=\"name\">closePre</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config\">Std.Tactic.Congr.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L17-L17","name":"Std.Tactic.Congr.Config.mk","line":17,"kind":"ctor","docLink":"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Congr</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(closePre : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(closePost : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config\">Std.Tactic.Congr.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Congr.lean#L17-L23","name":"Std.Tactic.Congr.Config","line":17,"kind":"structure","docLink":"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config","doc":"Configuration options for `congr` & `rcongr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Congr.html#Std.Tactic.Congr.Config\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Congr</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}