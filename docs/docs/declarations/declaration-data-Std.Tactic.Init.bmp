{"name":"Std.Tactic.Init","instances":[],"imports":["Init","Std.Tactic.GuardExpr","Std.Lean.Meta.Basic","Std.Lean.Tactic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L160-L161","name":"Std.Tactic.Conv.equals","line":160,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.Conv.equals","doc":"The `conv` tactic `equals` claims that the currently focused subexpression is equal\n to the given expression, and proves this claim using the given tactic.\n```\nexample (P : (Nat → Nat) → Prop) : P (fun n => n - n) := by\n  conv in (_ - _) => equals 0 =>\n    -- current goal: ⊢ n - n = 0\n    apply Nat.sub_self\n  -- current goal: P (fun n => 0)\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.Conv.equals\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">equals</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L148-L148","name":"Std.Tactic.Conv.exact","line":148,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.Conv.exact","doc":"`conv` tactic to close a goal using an equality theorem. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.Conv.exact\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Conv</span>.<span class=\"name\">exact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L144-L145","name":"Std.Tactic.triv","line":144,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.triv","doc":"Tries to solve the goal using a canonical proof of `True`, or the `rfl` tactic.\nUnlike `trivial` or `trivial'`, does not use the `contradiction` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.triv\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">triv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L125-L138","name":"Std.Tactic.tacticEapply_","line":125,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticEapply_","doc":"`eapply e` is like `apply e` but it does not add subgoals for variables that appear\nin the types of other goals. Note that this can lead to a failure where there are\nno goals remaining but there are still metavariables in the term:\n```\nexample (h : ∀ x : Nat, x = x → True) : True := by\n  eapply h\n  rfl\n  -- no goals\n-- (kernel) declaration has metavariables '_example'\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticEapply_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticEapply_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L118-L123","name":"Std.Tactic.tacticFapply_","line":118,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticFapply_","doc":"`fapply e` is like `apply e` but it adds goals in the order they appear,\nrather than putting the dependent goals first.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticFapply_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticFapply_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L114-L115","name":"Std.Tactic.tacticSplit_ands","line":114,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticSplit_ands","doc":"`split_ands` applies `And.intro` until it does not make progress. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticSplit_ands\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSplit_ands</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L111-L112","name":"Std.Tactic.tacticSubst_eqs","line":111,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticSubst_eqs","doc":"`subst_eqs` applies `subst` to all equalities in the context as long as it makes progress. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticSubst_eqs\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSubst_eqs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L104-L109","name":"Std.Tactic.tacticRepeat1'_","line":104,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticRepeat1'_","doc":"`repeat1' tac` applies `tac` to main goal at least once. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticRepeat1'_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRepeat1'_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L97-L102","name":"Std.Tactic.tacticRepeat'_","line":97,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticRepeat'_","doc":"`repeat' tac` runs `tac` on all of the goals to produce a new list of goals,\nthen runs `tac` again on all of those goals, and repeats until `tac` fails on all remaining goals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticRepeat'_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRepeat'_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L76-L88","name":"Std.Tactic.tacticIterate____","line":76,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticIterate____","doc":"`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\nTo run multiple tactics, one can do `iterate (tac₁; tac₂; ⋯)` or\n```lean\niterate\n  tac₁\n  tac₂\n  ⋯\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticIterate____\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticIterate____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L73-L74","name":"Std.Tactic.tacticAbsurd_","line":73,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticAbsurd_","doc":"Given a proof `h` of `p`, `absurd h` changes the goal to `⊢ ¬ p`.\nIf `p` is a negation `¬q` then the goal is changed to `⊢ q` instead.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticAbsurd_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAbsurd_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L58-L67","name":"Std.Tactic.byContra","line":58,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.byContra","doc":"`by_contra h` proves `⊢ p` by contradiction,\nintroducing a hypothesis `h : ¬p` and proving `False`.\n* If `p` is a negation `¬q`, `h : q` will be introduced instead of `¬¬q`.\n* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.\n* If `h` is omitted, the introduced variable `_: ¬p` will be anonymous.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.byContra\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">byContra</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L43-L49","name":"Std.Tactic.exacts","line":43,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.exacts","doc":"Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.exacts\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">exacts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L40-L41","name":"Std.Tactic.tacticRwa__","line":40,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticRwa__","doc":"`rwa` calls `rw`, then closes any remaining goals using `assumption`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticRwa__\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticRwa__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L27-L28","name":"Std.Tactic.failIfSuccessConv","line":27,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.failIfSuccessConv","doc":"`fail_if_success t` fails if the tactic `t` succeeds. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.failIfSuccessConv\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">failIfSuccessConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L25-L25","name":"Std.Tactic.tactic_","line":25,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tactic_","doc":"`_` in tactic position acts like the `done` tactic: it fails and gives the list\nof goals if there are any. It is useful as a placeholder after starting a tactic block\nsuch as `by _` to make it syntactically correct and show the current goal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tactic_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tactic_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Init.lean#L18-L18","name":"Std.Tactic.tacticExfalso","line":18,"kind":"def","docLink":"./Std/Tactic/Init.html#Std.Tactic.tacticExfalso","doc":"`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Init.html#Std.Tactic.tacticExfalso\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticExfalso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}