{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","className":"Coe"}],"imports":["Init","Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L791-L792","name":"Lean.Parser.Tactic.quotSeq","line":791,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quotSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L789-L790","name":"Lean.Parser.Tactic.quot","line":789,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L784-L785","name":"Lean.Parser.Term.dotIdent","line":784,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dotIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L781-L782","name":"Lean.Parser.Term.dynamicQuot","line":781,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dynamicQuot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L778-L779","name":"Lean.Parser.Term.stateRefT","line":778,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">stateRefT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L775-L775","name":"Lean.Parser.Term.macroLastArg","line":775,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroLastArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L774-L774","name":"Lean.Parser.Term.macroDollarArg","line":774,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroDollarArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L773-L773","name":"Lean.Parser.Term.macroArg","line":773,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L769-L770","name":"Lean.Parser.Term.assert","line":769,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.assert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">assert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L765-L767","name":"Lean.Parser.Term.dbgTrace","line":765,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dbgTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L759-L760","name":"Lean.Parser.Term.unreachable","line":759,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unreachable</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L756-L757","name":"Lean.Parser.Term.panic","line":756,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.panic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">panic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L746-L746","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","line":746,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinderF</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L745-L745","name":"Lean.Parser.Term.bracketedBinderF","line":745,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinderF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L742-L743","name":"Lean.Parser.Term.subst","line":742,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.subst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">subst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L731-L732","name":"Lean.Parser.Term.pipeCompletion","line":731,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeCompletion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L729-L730","name":"Lean.Parser.Term.pipeProj","line":729,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeProj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L720-L723","name":"Lean.Parser.Term.namedPattern","line":720,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` or `x:h@e` matches the pattern `e` and binds its value to the identifier `x`.\nIf present, the identifier `h` is bound to a proof of `x = e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L714-L717","name":"Lean.Parser.Term.explicitUniv","line":714,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitUniv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L709-L711","name":"Lean.Parser.Term.isIdent","line":709,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">isIdent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L706-L707","name":"Lean.Parser.Term.arrow","line":706,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.arrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">arrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L704-L705","name":"Lean.Parser.Term.completion","line":704,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.completion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">completion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L702-L703","name":"Lean.Parser.Term.proj","line":702,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.proj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">proj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L688-L688","name":"Lean.Parser.Term.app","line":688,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.app\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L681-L684","name":"Lean.Parser.Term.argument","line":681,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.argument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">argument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L679-L680","name":"Lean.Parser.Term.ellipsis","line":679,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ellipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L677-L678","name":"Lean.Parser.Term.namedArgument","line":677,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedArgument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L674-L675","name":"Lean.Parser.Term.noErrorIfUnused","line":674,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noErrorIfUnused</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L667-L668","name":"Lean.Parser.Term.defaultOrOfNonempty","line":667,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">defaultOrOfNonempty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L664-L665","name":"Lean.Parser.Term.waitIfContainsMVar","line":664,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L662-L663","name":"Lean.Parser.Term.waitIfTypeContainsMVar","line":662,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L660-L661","name":"Lean.Parser.Term.waitIfTypeMVar","line":660,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L658-L659","name":"Lean.Parser.Term.letMVar","line":658,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L655-L656","name":"Lean.Parser.Term.clear","line":655,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L648-L649","name":"Lean.Parser.Term.noImplicitLambda","line":648,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noImplicitLambda</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L646-L647","name":"Lean.Parser.Term.ensureExpectedType","line":646,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureExpectedType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L644-L645","name":"Lean.Parser.Term.ensureTypeOf","line":644,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureTypeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L642-L643","name":"Lean.Parser.Term.typeOf","line":642,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L640-L641","name":"Lean.Parser.Term.withDeclName","line":640,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withDeclName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L632-L632","name":"Lean.Parser.Term.declName","line":632,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.declName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L628-L629","name":"Lean.Parser.Term.forInMacro'","line":628,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L626-L627","name":"Lean.Parser.Term.forInMacro","line":626,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L623-L624","name":"Lean.Parser.Term.unop","line":623,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","doc":"`unop% f a` elaborates `f a` as a unary operation using the type propogation protocol in `Lean.Elab.Extra`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L620-L621","name":"Lean.Parser.Term.rightact","line":620,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.rightact","doc":"`rightact% f a b` elaborates `f a b` as a right action using the type propogation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `b`, where only the left argument `a` participates in the operator coercion elaborator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.rightact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">rightact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L616-L617","name":"Lean.Parser.Term.leftact","line":616,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leftact","doc":"`leftact% f a b` elaborates `f a b` as a left action using the type propogation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `a`, where only the right argument `b` participates in the operator coercion elaborator. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leftact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leftact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L612-L613","name":"Lean.Parser.Term.binop_lazy","line":612,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":"`binop_lazy%` is similar to `binop% f a b`, but it wraps `b` as a function from `Unit`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop_lazy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L609-L610","name":"Lean.Parser.Term.binop","line":609,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":"`binop% f a b` elaborates `f a b` as a binary operation using the type propogation protocol in `Lean.Elab.Extra`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L606-L607","name":"Lean.Parser.Term.binrel_no_prop","line":606,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"`binrel_no_prop% r a b` is similar to `binrel% r a b`, but it coerces `Prop` arguments into `Bool`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel_no_prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L603-L604","name":"Lean.Parser.Term.binrel","line":603,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":"`binrel% r a b` elaborates `r a b` as a binary relation using the type propogation protocol in `Lean.Elab.Extra`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L599-L600","name":"Lean.Parser.Term.noindex","line":599,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noindex\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noindex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L596-L597","name":"Lean.Parser.Term.matchAltsWhereDecls","line":596,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltsWhereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L592-L593","name":"Lean.Parser.Term.whereDecls","line":592,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L587-L589","name":"Lean.Parser.Term.letrec","line":587,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L584-L585","name":"Lean.Parser.Term.letRecDecls","line":584,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":"`letRecDecls` matches `letRecDecl,+`, a comma-separated list of let-rec declarations (see `letRecDecl`). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L581-L582","name":"Lean.Parser.Term.letRecDecl","line":581,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":"`letRecDecl` matches the body of a let-rec declaration: a doc comment, attributes, and then\na let declaration without the `let` keyword, such as `/-- foo -/ @[simp] bar := 1`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L577-L578","name":"Lean.Parser.Term.attributes","line":577,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attributes\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attributes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L575-L575","name":"Lean.Parser.Term.attrInstance","line":575,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrInstance</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L574-L574","name":"Lean.Parser.Term.attrKind","line":574,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":"`attrKind` matches `(\"scoped\" <|> \"local\")?`, used before an attribute like `@[local simp]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L572-L572","name":"Lean.Parser.Term.local","line":572,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.local\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">local</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L571-L571","name":"Lean.Parser.Term.scoped","line":571,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scoped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scoped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L568-L569","name":"Lean.Parser.Term.have","line":568,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.have\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">have</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L566-L567","name":"Lean.Parser.Term.haveDecl","line":566,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":"`haveDecl` matches the body of a have declaration: `have := e`, `have f x1 x2 := e`,\n`have pat := e` (where `pat` is an arbitrary term) or `have f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `have` keyword itself. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L561-L562","name":"Lean.Parser.Term.haveEqnsDecl","line":561,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L559-L560","name":"Lean.Parser.Term.haveIdDecl","line":559,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L558-L558","name":"Lean.Parser.Term.haveIdLhs","line":558,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L554-L555","name":"Lean.Parser.Term.let_tmp","line":554,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_tmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L548-L549","name":"Lean.Parser.Term.let_delayed","line":548,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_delayed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L543-L544","name":"Lean.Parser.Term.let_fun","line":543,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L536-L537","name":"Lean.Parser.Term.let","line":536,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L510-L514","name":"Lean.Parser.Term.letDecl","line":510,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":"`letDecl` matches the body of a let declaration `let f x1 x2 := e`,\n`let pat := e` (where `pat` is an arbitrary term) or `let f | pat1 => e1 | pat2 => e2 ...`\n(a pattern matching declaration), except for the `let` keyword itself.\n`let rec` declarations are not handled here. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L504-L505","name":"Lean.Parser.Term.letEqnsDecl","line":504,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L486-L487","name":"Lean.Parser.Term.letPatDecl","line":486,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letPatDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L484-L485","name":"Lean.Parser.Term.letIdDecl","line":484,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L480-L483","name":"Lean.Parser.Term.letIdLhs","line":480,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L476-L478","name":"Lean.Parser.Term.letIdBinder","line":476,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L473-L474","name":"Lean.Parser.Term.doubleQuotedName","line":473,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">doubleQuotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L466-L466","name":"Lean.Parser.Term.quotedName","line":466,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">quotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L463-L464","name":"Lean.Parser.Term.borrowed","line":463,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">borrowed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L460-L461","name":"Lean.Parser.Term.trailing_parser","line":460,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trailing_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L458-L459","name":"Lean.Parser.Term.leading_parser","line":458,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leading_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L455-L457","name":"Lean.Parser.Term.withAnonymousAntiquot","line":455,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withAnonymousAntiquot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L454-L454","name":"Lean.Parser.Term.optExprPrecedence","line":454,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optExprPrecedence</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L451-L452","name":"Lean.Parser.Term.fun","line":451,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L449-L450","name":"Lean.Parser.Term.basicFun","line":449,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">basicFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L444-L446","name":"Lean.Parser.Term.funBinder","line":444,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L439-L443","name":"Lean.Parser.Term.funStrictImplicitBinder","line":439,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funStrictImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L437-L438","name":"Lean.Parser.Term.funImplicitBinder","line":437,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L435-L435","name":"Lean.Parser.Term.nomatch","line":435,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nomatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L427-L429","name":"Lean.Parser.Term.match","line":427,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... => f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.match\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">match</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L390-L392","name":"Lean.Parser.Term.motive","line":390,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.motive\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">motive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L386-L388","name":"Lean.Parser.Term.generalizingParam","line":386,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">generalizingParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L385-L385","name":"Lean.Parser.Term.falseVal","line":385,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">falseVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L384-L384","name":"Lean.Parser.Term.trueVal","line":384,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trueVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L381-L382","name":"Lean.Parser.Term.matchDiscr","line":381,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":"`matchDiscr` matches a \"match discriminant\", either `h : tm` or `tm`, used in `match` as\n`match h1 : e1, e2, h3 : e3 with ...`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchDiscr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L376-L377","name":"Lean.Parser.Term.matchAlts","line":376,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> <span class=\"fn\">Lean.Parser.termParser</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L373-L374","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","line":373,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAltExpr</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L371-L371","name":"Lean.Parser.Term.matchAltExpr","line":371,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L362-L367","name":"Lean.Parser.Term.matchAlt","line":362,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> <span class=\"fn\">Lean.Parser.termParser</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L357-L360","name":"Lean.Parser.Term.forall","line":357,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forall\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L353-L354","name":"Lean.Parser.Term.depArrow","line":353,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">depArrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L333-L336","name":"Lean.Parser.Term.bracketedBinder","line":333,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":"A `bracketedBinder` matches any kind of binder group that uses some kind of brackets:\n* An explicit binder like `(x y : A)`\n* An implicit binder like `{x y : A}`\n* A strict implicit binder, `⦃y z : A⦄` or its ASCII alternative `{{y z : A}}`\n* An instance binder `[A]` or `[x : A]` (multiple variables are not allowed here)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L325-L326","name":"Lean.Parser.Term.instBinder","line":325,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by typeclass inference of the specified class.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L318-L320","name":"Lean.Parser.Term.strictImplicitBinder","line":318,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder. In contrast to `{ ... }` regular implicit binders,\na strict-implicit binder is inserted automatically only when at least one subsequent\nexplicit parameter is specified.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L312-L312","name":"Lean.Parser.Term.strictImplicitRightBracket","line":312,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitRightBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L311-L311","name":"Lean.Parser.Term.strictImplicitLeftBracket","line":311,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitLeftBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L309-L310","name":"Lean.Parser.Term.implicitBinder","line":309,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by unification whenever all explicit parameters before it are specified.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">implicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L303-L304","name":"Lean.Parser.Term.explicitBinder","line":303,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L294-L301","name":"Lean.Parser.Term.binderDefault.parenthesizer","line":294,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L290-L291","name":"Lean.Parser.Term.binderDefault","line":290,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L288-L289","name":"Lean.Parser.Term.binderTactic","line":288,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L286-L287","name":"Lean.Parser.Term.binderType","line":286,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L284-L285","name":"Lean.Parser.Term.inaccessible","line":284,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">inaccessible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L278-L279","name":"Lean.Parser.Term.explicit","line":278,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L273-L273","name":"Lean.Parser.Term.optType","line":273,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L272-L272","name":"Lean.Parser.Term.typeSpec","line":272,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeSpec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L267-L271","name":"Lean.Parser.Term.structInst","line":267,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L256-L257","name":"Lean.Parser.Term.optEllipsis","line":256,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optEllipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L253-L255","name":"Lean.Parser.Term.structInstFieldAbbrev","line":253,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldAbbrev</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L251-L252","name":"Lean.Parser.Term.structInstField","line":251,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstField</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L248-L250","name":"Lean.Parser.Term.structInstLVal","line":248,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstLVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L246-L247","name":"Lean.Parser.Term.structInstArrayRef","line":246,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstArrayRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L245-L245","name":"Lean.Parser.Term.show","line":245,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.show\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">show</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L243-L244","name":"Lean.Parser.Term.suffices","line":243,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.suffices\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">suffices</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L241-L242","name":"Lean.Parser.Term.sufficesDecl","line":241,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":"A `sufficesDecl` represents everything that comes after the `suffices` keyword:\nan optional `x :`, then a term `ty`, then `from val` or `by tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sufficesDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L238-L238","name":"Lean.Parser.Term.showRhs","line":238,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L236-L237","name":"Lean.Parser.Term.fromTerm","line":236,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fromTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L234-L235","name":"Lean.Parser.Term.optIdent","line":234,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L232-L233","name":"Lean.Parser.Term.anonymousCtor","line":232,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">anonymousCtor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L223-L224","name":"Lean.Parser.Term.paren","line":223,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L212-L213","name":"Lean.Parser.Term.tuple","line":212,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tuple","doc":"Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L209-L210","name":"Lean.Parser.Term.typeAscription","line":209,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":"Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeAscription</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L201-L202","name":"Lean.Parser.Term.cdot","line":201,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.cdot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">cdot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L195-L196","name":"Lean.Parser.Term.sorry","line":195,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sorry\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L193-L193","name":"Lean.Parser.Term.binderIdent","line":193,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L191-L192","name":"Lean.Parser.Term.syntheticHole","line":191,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":"Parses a \"synthetic hole\", that is, `?foo` or `?_`.\nThis syntax is used to construct named metavariables. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">syntheticHole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L187-L188","name":"Lean.Parser.Term.hole","line":187,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A placeholder term, to be synthesized by unification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L184-L185","name":"Lean.Parser.Term.prop","line":184,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L181-L182","name":"Lean.Parser.Term.sort","line":181,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sort\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sort</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L178-L179","name":"Lean.Parser.Term.type","line":178,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L175-L176","name":"Lean.Parser.Term.char","line":175,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.char\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L173-L174","name":"Lean.Parser.Term.str","line":173,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.str\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">str</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L171-L172","name":"Lean.Parser.Term.scientific","line":171,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scientific\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scientific</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L169-L170","name":"Lean.Parser.Term.num","line":169,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.num\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">num</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L167-L168","name":"Lean.Parser.Term.ident","line":167,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L163-L164","name":"Lean.Parser.Term.optSemicolon","line":163,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L159-L160","name":"Lean.Parser.Term.byTactic'","line":159,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L150-L151","name":"Lean.Parser.Term.byTactic","line":150,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L140-L141","name":"Lean.Parser.Termination.suffix","line":140,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.suffix","doc":"Termination hints are `termination_by` and `decreasing_by`, in that order.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.suffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">suffix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L134-L135","name":"Lean.Parser.Termination.decreasingBy","line":134,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy","doc":"Manually prove that the termination argument (as specified with `termination_by` or inferred)\ndecreases at each recursive call.\n\nBy default, the tactic `decreasing_tactic` is used.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.decreasingBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">decreasingBy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L122-L126","name":"Lean.Parser.Termination.terminationBy","line":122,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy","doc":"Specify a termination argument for well-founded termination:\n```\ntermination_by a - b\n```\nindicates that termination of the currently defined recursive function follows\nbecause the difference between the the arguments `a` and `b`.\n\nIf the fuction takes further argument after the colon, you can name them as follows:\n```\ndef example (a : Nat) : Nat → Nat → Nat :=\ntermination_by b c => a - b\n```\n\nIf omitted, a termination argument will be inferred.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Termination.terminationBy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Termination</span>.<span class=\"name\">terminationBy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L97-L97","name":"Lean.Parser.semicolonOrLinebreak","line":97,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">semicolonOrLinebreak</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L96-L96","name":"Lean.Parser.darrow","line":96,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.darrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">darrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L91-L92","name":"Lean.Parser.Tactic.seq1","line":91,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">seq1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L87-L88","name":"Lean.Parser.Tactic.tacticSeqIndentGt","line":87,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt","doc":"Same as [`tacticSeq`] but requires delimiter-free tactic sequence to have strict indentation.\nThe strict indentation requirement only apply to *nested* `by`s, as top-level `by`s do not have a\nposition set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqIndentGt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L81-L82","name":"Lean.Parser.Tactic.tacticSeq","line":81,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":"A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.\nDelimiter-free indentation is determined by the *first* tactic of the sequence. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L76-L77","name":"Lean.Parser.Tactic.tacticSeqBracketed","line":76,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L72-L73","name":"Lean.Parser.Tactic.tacticSeq1Indented","line":72,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L65-L66","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","line":65,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":"`sepBy1IndentSemicolon(p)` parses a (nonempty) sequence of `p` optionally followed by `;`,\nsimilar to `many1Indent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepBy1IndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L52-L53","name":"Lean.Parser.Tactic.sepByIndentSemicolon","line":52,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":"`sepByIndentSemicolon(p)` parses a sequence of `p` optionally followed by `;`,\nsimilar to `manyIndent(p \";\"?)`, except that if two occurrences of `p` occur on the same line,\nthe `;` is mandatory. This is used by tactic parsing, so that\n```\nexample := by\n  skip\n  skip\n```\nis legal, but `by skip skip` is not - it must be written as `by skip; skip`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepByIndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L37-L38","name":"Lean.Parser.convParser","line":37,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.convParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">convParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L34-L35","name":"Lean.Parser.tacticParser","line":34,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.tacticParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">tacticParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L26-L27","name":"Lean.Parser.Command.docComment","line":26,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":"A `docComment` parses a \"documentation comment\" like `/-- foo -/`. This is not treated like\na regular comment (that is, as whitespace); it is parsed and forms part of the syntax tree structure.\n\nA `docComment` node contains a `/--` atom and then the remainder of the comment, `foo -/` in this\nexample. Use `TSyntax.getDocString` to extract the body text from a doc string syntax node. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.docComment\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">docComment</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L19-L19","name":"Lean.Parser.Command.commentBody.formatter","line":19,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L17-L17","name":"Lean.Parser.Command.commentBody.parenthesizer","line":17,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/a5bc9013ab13f7b186cf154d396036b1d7c23370/src/Lean/Parser/Term.lean#L13-L14","name":"Lean.Parser.Command.commentBody","line":13,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"}]}