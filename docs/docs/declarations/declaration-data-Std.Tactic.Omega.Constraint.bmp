{"name":"Std.Tactic.Omega.Constraint","instances":[{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.instBEqConstraint","className":"BEq"},{"typeNames":["Eq"],"name":"Std.Tactic.Omega.instDecidableEqConstraint","className":"Decidable"},{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.instReprConstraint","className":"Repr"},{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.Constraint.instToExprConstraint","className":"Lean.ToExpr"},{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.Constraint.instToStringConstraint","className":"ToString"}],"imports":["Init","Std.Classes.Order","Std.Tactic.RCases","Std.Data.Option.Lemmas","Std.Tactic.Omega.Coeffs.IntList"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L251-L252","name":"Std.Tactic.Omega.Constraint.not_sat'_of_isImpossible","line":251,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat'_of_isImpossible","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat'_of_isImpossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">not_sat'_of_isImpossible</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible\">Std.Tactic.Omega.Constraint.isImpossible</a> <span class=\"fn\">c</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">c</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L245-L249","name":"Std.Tactic.Omega.Constraint.div_sat'","line":245,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">div_sat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.gcd\">Std.Tactic.Omega.Coeffs.gcd</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.dot\">Std.Tactic.Omega.Coeffs.dot</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div\">Std.Tactic.Omega.Constraint.div</a> <span class=\"fn\">c</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.gcd\">Std.Tactic.Omega.Coeffs.gcd</a> <span class=\"fn\">x</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.sdiv\">Std.Tactic.Omega.Coeffs.sdiv</a> <span class=\"fn\">x</span> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.gcd\">Std.Tactic.Omega.Coeffs.gcd</a> <span class=\"fn\">x</span></span>)</span></span></span>)</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L242-L243","name":"Std.Tactic.Omega.Constraint.combine_sat'","line":242,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combine_sat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ws : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">t</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine\">Std.Tactic.Omega.Constraint.combine</a> <span class=\"fn\">s</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L240-L240","name":"Std.Tactic.Omega.Constraint.sat'","line":240,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'","doc":"It is convenient below to say that a constraint is satisfied at the dot product of two vectors,\nso we make an abbreviation `sat'` for this.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">sat'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L212-L234","name":"Std.Tactic.Omega.Constraint.div_sat","line":212,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">div_sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">k</span></span> <a href=\"./Std/Classes/Dvd.html#Dvd.dvd\">∣</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div\">Std.Tactic.Omega.Constraint.div</a> <span class=\"fn\">c</span> <span class=\"fn\">k</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">t</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">↑<span class=\"fn\">k</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L208-L210","name":"Std.Tactic.Omega.Constraint.div","line":208,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div","doc":"Dividing a constraint by a natural number, and tightened to integer bounds.\nThus the lower bound is rounded up, and the upper bound is rounded down.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L193-L202","name":"Std.Tactic.Omega.Constraint.combine_sat","line":193,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combine_sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c' : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine\">Std.Tactic.Omega.Constraint.combine</a> <span class=\"fn\">c</span> <span class=\"fn\">c'</span></span>)</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c'</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L189-L191","name":"Std.Tactic.Omega.Constraint.combine","line":189,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine","doc":"The conjunction of two constraints. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combine</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L184-L186","name":"Std.Tactic.Omega.Constraint.combo_sat","line":184,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combo_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₁ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₂ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₁ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₂ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w₁ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₁</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₂</span> <span class=\"fn\">x₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo\">Std.Tactic.Omega.Constraint.combo</a> <span class=\"fn\">a</span> <span class=\"fn\">c₁</span> <span class=\"fn\">b</span> <span class=\"fn\">c₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">x₂</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L181-L182","name":"Std.Tactic.Omega.Constraint.combo","line":181,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo","doc":"A linear combination of two constraints. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L167-L178","name":"Std.Tactic.Omega.Constraint.add_sat","line":167,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">add_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₁ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₂ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₁ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₂ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w₁ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₁</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₂</span> <span class=\"fn\">x₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add\">Std.Tactic.Omega.Constraint.add</a> <span class=\"fn\">c₁</span> <span class=\"fn\">c₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x₂</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L163-L165","name":"Std.Tactic.Omega.Constraint.add","line":163,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add","doc":"The sum of two constraints. `[a, b] + [c, d] = [a + c, b + d]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L139-L160","name":"Std.Tactic.Omega.Constraint.scale_sat","line":139,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">scale_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale\">Std.Tactic.Omega.Constraint.scale</a> <span class=\"fn\">k</span> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L131-L137","name":"Std.Tactic.Omega.Constraint.scale","line":131,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale","doc":"Scale a constraint by multiplying by an integer.\n* If `k = 0` this is either impossible, if the original constraint was impossible,\n  or the `= 0` exact constraint.\n* If `k` is positive this takes `[x, y]` to `[k * x, k * y]`\n* If `k` is negative this takes `[x, y]` to `[k * y, k * x]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L118-L122","name":"Std.Tactic.Omega.Constraint.not_sat_of_isImpossible","line":118,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat_of_isImpossible","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat_of_isImpossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">not_sat_of_isImpossible</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible\">Std.Tactic.Omega.Constraint.isImpossible</a> <span class=\"fn\">c</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L114-L116","name":"Std.Tactic.Omega.Constraint.isExact","line":114,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isExact","doc":"Check if a constraint requires an exact value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isExact\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">isExact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L109-L111","name":"Std.Tactic.Omega.Constraint.isImpossible","line":109,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible","doc":"Check if a constraint is unsatisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">isImpossible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L104-L106","name":"Std.Tactic.Omega.Constraint.exact_sat","line":104,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">exact_sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact\">Std.Tactic.Omega.Constraint.exact</a> <span class=\"fn\">r</span></span>)</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable.decide\">decide</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L101-L102","name":"Std.Tactic.Omega.Constraint.trivial_say","line":101,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial_say","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial_say\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">trivial_say</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial\">Std.Tactic.Omega.Constraint.trivial</a> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L99-L99","name":"Std.Tactic.Omega.Constraint.exact","line":99,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact","doc":"An exact constraint. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">exact</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L97-L97","name":"Std.Tactic.Omega.Constraint.impossible","line":97,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.impossible","doc":"The impossible constraint, unsatisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.impossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">impossible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L95-L95","name":"Std.Tactic.Omega.Constraint.trivial","line":95,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial","doc":"The trivial constraint, satisfied everywhere. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">trivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L86-L92","name":"Std.Tactic.Omega.Constraint.neg_sat","line":86,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">neg_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg\">Std.Tactic.Omega.Constraint.neg</a> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">v</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L84-L84","name":"Std.Tactic.Omega.Constraint.neg","line":84,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg","doc":"Negate a constraint. `[x, y]` becomes `[-y, -x]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L77-L79","name":"Std.Tactic.Omega.Constraint.flip","line":77,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.flip","doc":"Flip a constraint.\nThis operation is not useful by itself, but is used to implement `neg` and `scale`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.flip\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">flip</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L65-L71","name":"Std.Tactic.Omega.Constraint.translate_sat","line":65,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">translate_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate\">Std.Tactic.Omega.Constraint.translate</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">v</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L63-L63","name":"Std.Tactic.Omega.Constraint.translate","line":63,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate","doc":"Translate a constraint. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">translate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L58-L60","name":"Std.Tactic.Omega.Constraint.map","line":58,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.map","doc":"Apply a function to both the lower bound and upper bound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.map\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L55-L55","name":"Std.Tactic.Omega.Constraint.sat","line":55,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat","doc":"A constraint is satisfied at `t` is both the lower bound and upper bound are satisfied. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L46-L52","name":"Std.Tactic.Omega.Constraint.instToStringConstraint","line":46,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToStringConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToStringConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">instToStringConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L41-L44","name":"Std.Tactic.Omega.Constraint.instToExprConstraint","line":41,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToExprConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToExprConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">instToExprConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L36-L36","name":"Std.Tactic.Omega.instReprConstraint","line":36,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instReprConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instReprConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">instReprConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L36-L36","name":"Std.Tactic.Omega.instDecidableEqConstraint","line":36,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instDecidableEqConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instDecidableEqConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">instDecidableEqConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L36-L36","name":"Std.Tactic.Omega.instBEqConstraint","line":36,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instBEqConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instBEqConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">instBEqConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L35-L35","name":"Std.Tactic.Omega.Constraint.upperBound","line":35,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.upperBound","doc":"An upper bound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.upperBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">upperBound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\">Std.Tactic.Omega.UpperBound</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L33-L33","name":"Std.Tactic.Omega.Constraint.lowerBound","line":33,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.lowerBound","doc":"A lower bound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.lowerBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">lowerBound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\">Std.Tactic.Omega.LowerBound</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L31-L31","name":"Std.Tactic.Omega.Constraint.mk","line":31,"kind":"ctor","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lowerBound : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\">Std.Tactic.Omega.LowerBound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(upperBound : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\">Std.Tactic.Omega.UpperBound</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L31-L36","name":"Std.Tactic.Omega.Constraint","line":31,"kind":"structure","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint","doc":"A `Constraint` consists of an optional lower and upper bound (inclusive),\nconstraining a value to a set of the form `∅`, `{x}`, `[x, y]`, `[x, ∞)`, `(-∞, y]`, or `(-∞, ∞)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L25-L25","name":"Std.Tactic.Omega.UpperBound.sat","line":25,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound.sat","doc":"A upper bound at `y` is satisfied at `t` if `t ≤ y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound.sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">UpperBound</span>.<span class=\"name\">sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\">Std.Tactic.Omega.UpperBound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L23-L23","name":"Std.Tactic.Omega.LowerBound.sat","line":23,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound.sat","doc":"A lower bound at `x` is satisfied at `t` if `x ≤ t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound.sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">LowerBound</span>.<span class=\"name\">sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\">Std.Tactic.Omega.LowerBound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L20-L20","name":"Std.Tactic.Omega.UpperBound","line":20,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound","doc":"An optional upper bound on a integer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">UpperBound</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/a7543d1a6934d52086971f510e482d743fe30cf3/Std/Tactic/Omega/Constraint.lean#L18-L18","name":"Std.Tactic.Omega.LowerBound","line":18,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound","doc":"An optional lower bound on a integer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">LowerBound</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}